---
title: "Pipelines with several MCMC runs"
output: rmarkdown::html_vignette
bibliography: mcmc_rep.bib
vignette: >
  %\VignetteIndexEntry{Pipelines with several MCMC runs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
# With the root.dir option below,
# this vignette runs the R code in a temporary directory
# so new files are written to temporary storage
# and not the user's file space.
knitr::opts_knit$set(root.dir = fs::dir_create(tempfile()))
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
if (identical(Sys.getenv("NOT_CRAN", unset = "false"), "false")) {
  knitr::opts_chunk$set(eval = FALSE)
}
library(cmdstanr)
library(dplyr)
library(targets)
library(stantargets)
```

It is sometimes desirable to run one or more Bayesian models repeatedly across multiple simulated datasets. Examples:

1. Validate the implementation of a Bayesian model using simulation.
2. Simulate a randomized controlled experiment to explore frequentist properties such as power and Type I error.

This vignette focuses on (1). The goal of this particular example to simulate multiple datasets from the model below, analyze each dataset, and assess how often the estimated posterior intervals cover the true parameters from the prior predictive simulations. The quantile method by @cook2006 generalizes this concept, and simulation-based calibration [@talts2020] generalizes further. The interval-based technique featured in this vignette is not as robust as SBC, but it may be more expedient for large models because it does not require visual inspection of multiple histograms.

```{r}
lines <- "data {
  int <lower = 1> n;
  vector[n] x;
  vector[n] y;
}
parameters {
  real alpha;
  vector[n] beta;
}
model {
  y ~ normal(alpha + x .* beta, 1);
  alpha ~ normal(0, 1);
  beta ~ normal(0, 1);
}"
writeLines(lines, "model.stan")
```

Next, we define a pipeline to simulate multiple datasets and fit each dataset with the model. Below, we commit to 10 replications: 2 batches with 5 iterations per batch. (In practical situations, the total number of replications should be hundreds of times more.) Our input data has a special 
`.join_data` list, which gets appended scalar-by-scalar to the numerical summaries of the correspondingly named model parameters.

```{r, echo = FALSE}
library(targets)
tar_script({
  library(stantargets)
  options(crayon.enabled = FALSE)
  tar_option_set(memory = "transient", garbage_collection = TRUE)
  simulate_data <- function(n = 10L) {
    alpha <- rnorm(n = 1, mean = 0, sd = 1)
    beta <- rnorm(n = n, mean = 0, sd = 1)
    x <- seq(from = -1, to = 1, length.out = n)
    y <- rnorm(n, alpha + x * beta, 1)
    list(
      n = n,
      x = x,
      y = y,
      .join_data = list(alpha = alpha, beta = beta)
    )
  }
  list(
    tar_stan_mcmc_rep_summary(
      model,
      "model.stan",
      simulate_data(),
      batches = 5, # Number of branch targets.
      reps = 2, # Number of model reps per branch target.
      variables = c("alpha", "beta"),
      summaries = list(
        ~posterior::quantile2(.x, probs = c(0.025, 0.975))
      ),
      log = R.utils::nullfile()
    )
  )
})
```

```{r, eval = FALSE}
# _targets.R
library(targets)
library(stantargets)
options(crayon.enabled = FALSE)
tar_option_set(memory = "transient", garbage_collection = TRUE)

simulate_data <- function(n = 10L) {
  alpha <- rnorm(n = 1, mean = 0, sd = 1)
  beta <- rnorm(n = n, mean = 0, sd = 1)
  x <- seq(from = -1, to = 1, length.out = n)
  y <- rnorm(n, alpha + x * beta, 1)
  list(
    n = n,
    x = x,
    y = y,
    .join_data = list(alpha = alpha, beta = beta)
  )
}

list(
  tar_stan_mcmc_rep_summary(
    model,
    "model.stan",
    simulate_data(), # Runs once per rep.
    batches = 5, # Number of branch targets.
    reps = 2, # Number of model reps per branch target.
    variables = c("alpha", "beta"),
    summaries = list(
      ~posterior::quantile2(.x, probs = c(0.025, 0.975))
    ),
    log = R.utils::nullfile()
  )
)
```

We now have a pipeline that runs the model 10 times: 5 batches (branch targets) with 2 replications per batch.

```{r}
tar_visnetwork()
```

Run the computation with `tar_make()`

```{r, output = FALSE, warning = FALSE}
tar_make()
```

The result is an aggregated data frame of summary statistics, where the `.rep` column distinguishes among individual replicates. We have the posterior intervals for `beta` in columns `q2.5` and `q97.5`. And thanks to `.join_data` in `simulate_data()`, there is a special `.join_data` column in the output to indicate the true value of each parameter from the simulation.

```{r}
tar_load(model)
model
```

Now, let's assess how often the estimated 95% posterior intervals capture the true values of `beta`. If the model is implemented correctly, the coverage value below should be close to 95%. (Ordinarily, we would [increase the number of batches and reps per batch](https://books.ropensci.org/targets/dynamic.html#batching) and [run batches in parallel computing](https://books.ropensci.org/targets/hpc.html).)

```{r}
library(dplyr)
model %>%
  group_by(variable) %>%
  summarize(coverage = mean(q2.5 < .join_data & .join_data < q97.5))
```
For maximum reproducibility, we should express the coverage assessment as a custom function and a target in the pipeline.

```{r, echo = FALSE}
library(targets)
tar_script({
  library(stantargets)
  options(crayon.enabled = FALSE)
  tar_option_set(
    packages = "dplyr",
    memory = "transient",
    garbage_collection = TRUE
  )
  simulate_data <- function(n = 10L) {
    alpha <- rnorm(n = 1, mean = 0, sd = 1)
    beta <- rnorm(n = n, mean = 0, sd = 1)
    x <- seq(from = -1, to = 1, length.out = n)
    y <- rnorm(n, alpha + x * beta, 1)
    list(
      n = n,
      x = x,
      y = y,
      .join_data = list(alpha = alpha, beta = beta)
    )
  }
  list(
    tar_stan_mcmc_rep_summary(
      model,
      "model.stan",
      simulate_data(),
      batches = 5, # Number of branch targets.
      reps = 2, # Number of model reps per branch target.
      variables = c("alpha", "beta"),
      summaries = list(
        ~posterior::quantile2(.x, probs = c(0.025, 0.975))
      ),
      log = R.utils::nullfile()
    ),
    tar_target(
      coverage,
      model %>%
        group_by(variable) %>%
        summarize(coverage = mean(q2.5 < .join_data & .join_data < q97.5))
    )
  )
})
```

```{r, eval = FALSE}
# _targets.R
library(targets)
library(stantargets)

simulate_data <- function(n = 10L) {
  alpha <- rnorm(n = 1, mean = 0, sd = 1)
  beta <- rnorm(n = n, mean = 0, sd = 1)
  x <- seq(from = -1, to = 1, length.out = n)
  y <- rnorm(n, alpha + x * beta, 1)
  list(
    n = n,
    x = x,
    y = y,
    .join_data = list(alpha = alpha, beta = beta)
  )
}

list(
  tar_stan_mcmc_rep_summary(
    model,
    "model.stan",
    simulate_data(),
    batches = 5, # Number of branch targets.
    reps = 2, # Number of model reps per branch target.
    variables = c("alpha", "beta"),
    summaries = list(
      ~posterior::quantile2(.x, probs = c(0.025, 0.975))
    ),
    log = R.utils::nullfile()
  ),
  tar_target(
    coverage,
    model %>%
      group_by(variable) %>%
      summarize(coverage = mean(q2.5 < .join_data & .join_data < q97.5))
  )
)
```

The new `coverage` target should the only outdated target, and it should be connected to the upstream `model` target.

```{r}
tar_visnetwork()
```

When we run the pipeline, only the coverage assessment should run. That way, we skip all the expensive computation of simulating datasets and running MCMC multiple times.

```{r, output = FALSE, warning = FALSE}
tar_make()
```

```{r}
tar_read(coverage)
```

## Multiple models

`tar_stan_rep_mcmc_summary()` and similar functions allow you to supply multiple Stan models. If you do, each model will share the the same collection of datasets. Below, we add a new `model2.stan` file to the `stan_files` argument of `tar_stan_rep_mcmc_summary()`. In the coverage summary below, we group by `.name` to compute a coverage statistic for each model.


```{r, echo = FALSE}
library(targets)
tar_script({
  library(stantargets)
  options(crayon.enabled = FALSE)
  tar_option_set(
    packages = "dplyr",
    memory = "transient",
    garbage_collection = TRUE
  )
  simulate_data <- function(n = 10L) {
    alpha <- rnorm(n = 1, mean = 0, sd = 1)
    beta <- rnorm(n = n, mean = 0, sd = 1)
    x <- seq(from = -1, to = 1, length.out = n)
    y <- rnorm(n, alpha + x * beta, 1)
    list(
      n = n,
      x = x,
      y = y,
      .join_data = list(alpha = alpha, beta = beta)
    )
  }
  list(
    tar_stan_mcmc_rep_summary(
      model,
      c("model.stan", "model2.stan"), # another model
      simulate_data(),
      batches = 5,
      reps = 2,
      variables = c("alpha", "beta"),
      summaries = list(
        ~posterior::quantile2(.x, probs = c(0.025, 0.975))
      ),
      log = R.utils::nullfile()
    ),
    tar_target(
      coverage,
      model %>%
        group_by(.name, variable) %>%
        summarize(coverage = mean(q2.5 < .join_data & .join_data < q97.5))
    )
  )
})
```

```{r, eval = FALSE}
# _targets.R
library(targets)
library(stantargets)

simulate_data <- function(n = 10L) {
  alpha <- rnorm(n = 1, mean = 0, sd = 1)
  beta <- rnorm(n = n, mean = 0, sd = 1)
  x <- seq(from = -1, to = 1, length.out = n)
  y <- rnorm(n, alpha + x * beta, 1)
  list(
    n = n,
    x = x,
    y = y,
    .join_data = list(alpha = alpha, beta = beta)
  )
}

list(
  tar_stan_mcmc_rep_summary(
    model,
    c("model.stan", "model2.stan"), # another model
    simulate_data(),
    batches = 5,
    reps = 2,
    variables = c("alpha", "beta"),
    summaries = list(
      ~posterior::quantile2(.x, probs = c(0.025, 0.975))
    ),
    log = R.utils::nullfile()
  ),
  tar_target(
    coverage,
    model %>%
      group_by(.name, variable) %>%
      summarize(coverage = mean(q2.5 < .join_data & .join_data < q97.5))
  )
)
```

In the graph below, notice how targets `model_model1` and `model_model2` are both connected to `model_data` upstream. Downstream, `model` is equivalent to `dplyr::bind_rows(model_model1, model_model2)`, and it will have special columns `.name` and `.file` to distinguish among all the models.

```{r}
tar_visnetwork()
```

## References
