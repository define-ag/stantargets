% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tar_stan_mcmc_rep_diagnostics.R
\name{tar_stan_mcmc_rep_diagnostics}
\alias{tar_stan_mcmc_rep_diagnostics}
\title{Multiple MCMCs with sampler diagnostics.}
\usage{
tar_stan_mcmc_rep_diagnostics(
  name,
  file,
  data = list(),
  batches = 1L,
  reps = 1L,
  compile = c("original", "copy"),
  quiet = TRUE,
  dir = NULL,
  include_paths = NULL,
  cpp_options = list(),
  stanc_options = list(),
  force_recompile = FALSE,
  seed = NULL,
  refresh = NULL,
  init = NULL,
  save_latent_dynamics = FALSE,
  output_dir = NULL,
  chains = 4,
  parallel_chains = getOption("mc.cores", 1),
  chain_ids = seq_len(chains),
  threads_per_chain = NULL,
  iter_warmup = NULL,
  iter_sampling = NULL,
  save_warmup = FALSE,
  thin = NULL,
  max_treedepth = NULL,
  adapt_engaged = TRUE,
  adapt_delta = NULL,
  step_size = NULL,
  metric = NULL,
  metric_file = NULL,
  inv_metric = NULL,
  init_buffer = NULL,
  term_buffer = NULL,
  window = NULL,
  fixed_param = FALSE,
  sig_figs = NULL,
  validate_csv = TRUE,
  show_messages = TRUE,
  inc_warmup = FALSE,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue")
)
}
\arguments{
\item{name}{Symbol, base name for the collection of targets.
Suffixes of the final targets depend on \code{stan_names}}

\item{data}{Code to generate one simulated dataset for one rep of the model.}

\item{batches}{Number of batches. Each batch is a branch target
that generates a dataset and runs the model \code{reps} times.}

\item{reps}{Number of model runs per batch.}

\item{compile}{Do compilation? The default is \code{TRUE}. If \code{FALSE}
compilation can be done later via the \code{\link[cmdstanr:model-method-compile]{$compile()}}
method.}

\item{quiet}{\code{quiet} argument to \verb{$compile()}.}

\item{dir}{\code{dir} argument to \verb{$compile()}.}

\item{include_paths}{\code{include_paths} argument to \verb{$compile()}.}

\item{cpp_options}{\code{cpp_options} argument to \verb{$compile()}.}

\item{stanc_options}{\code{stanc_options} argument to \verb{$compile()}.}

\item{force_recompile}{\code{force_recompile} argument to \verb{$compile()}.}

\item{seed}{\code{seed} argument to \verb{$sample()}.}

\item{refresh}{\code{refresh} argument to \verb{$sample()}.}

\item{init}{\code{init} argument to \verb{$sample()}.}

\item{save_latent_dynamics}{\code{save_latent_dynamics} argument to \verb{$sample()}.}

\item{output_dir}{\code{output_dir} argument to \verb{$sample()}.}

\item{chains}{\code{chains} argument to \verb{$sample()}.}

\item{parallel_chains}{\code{parallel_chains} argument to \verb{$sample()}.}

\item{chain_ids}{\code{chain_ids} argument to \verb{$sample()}.}

\item{threads_per_chain}{\code{threads_per_chain} argument to \verb{$sample()}.}

\item{iter_warmup}{\code{iter_warmup} argument to \verb{$sample()}.}

\item{iter_sampling}{\code{iter_sampling} argument to \verb{$sample()}.}

\item{save_warmup}{\code{save_warmup} argument to \verb{$sample()}.}

\item{thin}{\code{thin} argument to \verb{$sample()}.}

\item{max_treedepth}{\code{max_treedepth} argument to \verb{$sample()}.}

\item{adapt_engaged}{\code{adapt_engaged} argument to \verb{$sample()}.}

\item{adapt_delta}{\code{adapt_delta} argument to \verb{$sample()}.}

\item{step_size}{\code{step_size} argument to \verb{$sample()}.}

\item{metric}{\code{metric} argument to \verb{$sample()}.}

\item{metric_file}{\code{metric_file} argument to \verb{$sample()}.}

\item{inv_metric}{\code{inv_metric} argument to \verb{$sample()}.}

\item{init_buffer}{\code{init_buffer} argument to \verb{$sample()}.}

\item{term_buffer}{\code{term_buffer} argument to \verb{$sample()}.}

\item{window}{\code{window} argument to \verb{$sample()}.}

\item{fixed_param}{\code{fixed_param} argument to \verb{$sample()}.}

\item{sig_figs}{\code{sig_figs} argument to \verb{$sample()}.}

\item{validate_csv}{\code{validate_csv} argument to \verb{$sample()}.}

\item{show_messages}{\code{show_messages} argument to \verb{$sample()}.}

\item{inc_warmup}{\code{inc_warmup} argument to
\verb{$sampler_diagnostics()} on the \code{CmdStanMCMC} object.}

\item{tidy_eval}{Logical, whether to enable tidy evaluation
when interpreting \code{command} and \code{pattern}. If \code{TRUE}, you can use the
"bang-bang" operator \verb{!!} to programmatically insert
the values of global objects.}

\item{packages}{Character vector of packages to load right before
the target builds. Use \code{tar_option_set()} to set packages
globally for all subsequent targets you define.}

\item{library}{Character vector of library paths to try
when loading \code{packages}.}

\item{error}{Character of length 1, what to do if the target
runs into an error. If \code{"stop"}, the whole pipeline stops
and throws an error. If \code{"continue"}, the error is recorded,
but the pipeline keeps going.}

\item{memory}{Character of length 1, memory strategy.
If \code{"persistent"}, the target stays in memory
until the end of the pipeline (unless \code{storage} is \code{"worker"},
in which case \code{targets} unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If \code{"transient"}, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files such as \code{format = "aws_file"},
this memory policy applies to
temporary local copies of the file in \verb{_targets/scratch/"}:
\code{"persistent"} means they remain until the end of the pipeline,
and \code{"transient"} means they get deleted from the file system
as soon as possible. The former conserves bandwidth,
and the latter conserves local storage.}

\item{garbage_collection}{Logical, whether to run \code{base::gc()}
just before the target runs.}

\item{deployment}{Character of length 1, only relevant to
\code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[targets:tar_make_future]{tar_make_future()}}. If \code{"worker"},
the target builds on a parallel worker. If \code{"main"},
the target builds on the host machine / process managing the pipeline.}

\item{priority}{Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get built earlier.
Only applies to \code{\link[targets:tar_make_future]{tar_make_future()}} and \code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}}
(not \code{\link[targets:tar_make]{tar_make()}}). \code{\link[targets:tar_make_future]{tar_make_future()}} with no extra settings is
a drop-in replacement for \code{\link[targets:tar_make]{tar_make()}} in this case.}

\item{resources}{A named list of computing resources. Uses:
\itemize{
\item Template file wildcards for \code{future::future()} in \code{\link[targets:tar_make_future]{tar_make_future()}}.
\item Template file wildcards \code{clustermq::workers()} in \code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}}.
\item Custom target-level \code{future::plan()}, e.g.
\code{resources = list(plan = future.callr::callr)}.
\item Custom \code{curl} handle if \code{format = "url"},
e.g. \code{resources = list(handle = curl::new_handle())}.
\item Custom preset for \code{qs::qsave()} if \code{format = "qs"}, e.g.
\code{resources = list(handle = "archive")}.
\item Custom compression level for \code{fst::write_fst()} if
\code{format} is \code{"fst"}, \code{"fst_dt"}, or \code{"fst_tbl"}, e.g.
\code{resources = list(compress = 100)}.
\item AWS bucket and prefix for the \code{"aws_"} formats, e.g.
\code{resources = list(bucket = "your-bucket", prefix = "folder/name")}.
\code{bucket} is required for AWS formats. See the cloud computing chapter
of the manual for details.
}}

\item{storage}{Character of length 1, only relevant to
\code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[targets:tar_make_future]{tar_make_future()}}.
If \code{"main"}, the target's return value is sent back to the
host machine and saved locally. If \code{"worker"}, the worker
saves the value.}

\item{retrieval}{Character of length 1, only relevant to
\code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[targets:tar_make_future]{tar_make_future()}}.
If \code{"main"}, the target's dependencies are loaded on the host machine
and sent to the worker before the target builds.
If \code{"worker"}, the worker loads the targets dependencies.}

\item{cue}{An optional object from \code{tar_cue()} to customize the
rules that decide whether the target is up to date.}
}
\value{
\code{tar_stan_mcmc_rep_diagnostics(name = x, ...)} returns a list
of \code{targets::tar_target()} objects:
\itemize{
\item \code{x_file}: reproducibly track the Stan model file.
\item \code{x_lines}: contents of the Stan model file.
Omitted if \code{compile = "original"}.
\item \code{x_data}: dynamic branching target with simulated datasets.
\item \code{x}: dynamic branching target with tidy data frames of MCMC
sampler diagnostics.
}
}
\description{
Targets to run MCMC multiple times and
save only the sampler diagnostics from each run. We recommend thinning
if the number of MCMC runs is large.
}
\details{
Most of the arguments are passed to the \verb{$compile()}
and \verb{$sample()} methods of the \code{CmdStanModel} class. If you
previously compiled the model in an upstream \code{\link[=tar_stan_compile]{tar_stan_compile()}}
target, then the model should not recompile.
}
\examples{
# First, write your Stan model file. Example:
# tar_stan_example_file() # Writes stantargets_example.stan
# Then in _targets.R, write the pipeline:
targets::tar_pipeline(
  tar_stan_compile(compiled_model, "stantargets_example.stan"),
  tar_stan_mcmc_rep_diagnostics(
    your_model,
    file = compiled_model,
    data = tar_stan_example_data(),
    batches = 2,
    reps = 2
  )
)
}
