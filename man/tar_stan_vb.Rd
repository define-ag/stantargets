% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tar_stan_vb.R
\name{tar_stan_vb}
\alias{tar_stan_vb}
\title{One variational Bayes run with multiple outputs.}
\usage{
tar_stan_vb(
  name,
  file,
  data = list(),
  compile = c("original", "copy"),
  quiet = TRUE,
  dir = NULL,
  include_paths = NULL,
  cpp_options = list(),
  stanc_options = list(),
  force_recompile = FALSE,
  seed = NULL,
  refresh = NULL,
  init = NULL,
  save_latent_dynamics = FALSE,
  output_dir = NULL,
  algorithm = NULL,
  iter = NULL,
  grad_samples = NULL,
  elbo_samples = NULL,
  eta = NULL,
  adapt_engaged = NULL,
  adapt_iter = NULL,
  tol_rel_obj = NULL,
  eval_elbo = NULL,
  output_samples = NULL,
  sig_figs = NULL,
  variables = NULL,
  summaries = list(),
  summary_args = list(),
  draws = TRUE,
  summary = TRUE,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue")
)
}
\arguments{
\item{name}{Symbol, base name for the collection of targets.
The name itself will be applied to the fit object itself,
and there will be suffixes for various supporting targets.}

\item{file}{Code to generate the \code{stan_file}
argument of \verb{$compile()}. Could just be a literal path to a
Stan model file or the name of an upstream target
defined by \code{\link[=tar_stan_compile]{tar_stan_compile()}}.}

\item{data}{Code to generate the \code{data} argument of \verb{$variational()}.}

\item{compile}{Do compilation? The default is \code{TRUE}. If \code{FALSE}
compilation can be done later via the \code{\link[cmdstanr:model-method-compile]{$compile()}}
method.}

\item{quiet}{\code{quiet} argument to \verb{$compile()}.}

\item{dir}{\code{dir} argument to \verb{$compile()}.}

\item{include_paths}{\code{include_paths} argument to \verb{$compile()}.}

\item{cpp_options}{\code{cpp_options} argument to \verb{$compile()}.}

\item{stanc_options}{\code{stanc_options} argument to \verb{$compile()}.}

\item{force_recompile}{\code{force_recompile} argument to \verb{$compile()}.}

\item{seed}{\code{seed} argument to \verb{$variational()}.}

\item{refresh}{\code{refresh} argument to \verb{$variational()}.}

\item{init}{\code{init} argument to \verb{$variational()}.}

\item{save_latent_dynamics}{\code{save_latent_dynamics}
argument to \verb{$variational()}.}

\item{output_dir}{\code{output_dir} argument to \verb{$variational()}.}

\item{algorithm}{\code{algorithm} argument to \verb{$variational()}.}

\item{iter}{\code{iter} argument to \verb{$variational()}.}

\item{grad_samples}{\code{grad_samples} argument to \verb{$variational()}.}

\item{elbo_samples}{\code{elbo_samples} argument to \verb{$variational()}.}

\item{eta}{\code{eta} argument to \verb{$variational()}.}

\item{adapt_engaged}{\code{adapt_engaged} argument to \verb{$variational()}.}

\item{adapt_iter}{\code{adapt_iter} argument to \verb{$variational()}.}

\item{tol_rel_obj}{\code{tol_rel_obj} argument to \verb{$variational()}.}

\item{eval_elbo}{\code{eval_elbo} argument to \verb{$variational()}.}

\item{output_samples}{\code{output_samples} argument to \verb{$variational()}.}

\item{sig_figs}{\code{sig_figs} argument to \verb{$variational()}.}

\item{variables}{\code{variables} argument to \verb{$draws()} and \verb{$summary()}
on the \code{CmdStanVB} object.}

\item{summaries}{Optional list of summary functions passed to \code{...} in
\code{posterior::summarize_draws()} through \verb{$summary()}
on the \code{CmdStanFit} object.}

\item{summary_args}{Optional list of summary function arguments passed to
\code{.args} in \code{posterior::summarize_draws()} through \verb{$summary()}
on the \code{CmdStanFit} object.}

\item{draws}{Logical, whether to create a target for posterior draws.
Saves \code{posterior::as_draws_df(fit$draws())} to a compressed \code{tibble}.
Convenient, but duplicates storage.}

\item{summary}{Logical, whether to create a target for
\code{fit$summary()}.}

\item{tidy_eval}{Logical, whether to enable tidy evaluation
when interpreting \code{command} and \code{pattern}. If \code{TRUE}, you can use the
"bang-bang" operator \verb{!!} to programmatically insert
the values of global objects.}

\item{packages}{Character vector of packages to load right before
the target builds. Use \code{tar_option_set()} to set packages
globally for all subsequent targets you define.}

\item{library}{Character vector of library paths to try
when loading \code{packages}.}

\item{error}{Character of length 1, what to do if the target
runs into an error. If \code{"stop"}, the whole pipeline stops
and throws an error. If \code{"continue"}, the error is recorded,
but the pipeline keeps going.}

\item{memory}{Character of length 1, memory strategy.
If \code{"persistent"}, the target stays in memory
until the end of the pipeline (unless \code{storage} is \code{"worker"},
in which case \code{targets} unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If \code{"transient"}, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files such as \code{format = "aws_file"},
this memory policy applies to
temporary local copies of the file in \verb{_targets/scratch/"}:
\code{"persistent"} means they remain until the end of the pipeline,
and \code{"transient"} means they get deleted from the file system
as soon as possible. The former conserves bandwidth,
and the latter conserves local storage.}

\item{garbage_collection}{Logical, whether to run \code{base::gc()}
just before the target runs.}

\item{deployment}{Character of length 1, only relevant to
\code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[targets:tar_make_future]{tar_make_future()}}. If \code{"worker"},
the target builds on a parallel worker. If \code{"main"},
the target builds on the host machine / process managing the pipeline.}

\item{priority}{Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get built earlier.
Only applies to \code{\link[targets:tar_make_future]{tar_make_future()}} and \code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}}
(not \code{\link[targets:tar_make]{tar_make()}}). \code{\link[targets:tar_make_future]{tar_make_future()}} with no extra settings is
a drop-in replacement for \code{\link[targets:tar_make]{tar_make()}} in this case.}

\item{resources}{A named list of computing resources. Uses:
\itemize{
\item Template file wildcards for \code{future::future()} in \code{\link[targets:tar_make_future]{tar_make_future()}}.
\item Template file wildcards \code{clustermq::workers()} in \code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}}.
\item Custom target-level \code{future::plan()}, e.g.
\code{resources = list(plan = future.callr::callr)}.
\item Custom \code{curl} handle if \code{format = "url"},
e.g. \code{resources = list(handle = curl::new_handle())}.
\item Custom preset for \code{qs::qsave()} if \code{format = "qs"}, e.g.
\code{resources = list(handle = "archive")}.
\item Custom compression level for \code{fst::write_fst()} if
\code{format} is \code{"fst"}, \code{"fst_dt"}, or \code{"fst_tbl"}, e.g.
\code{resources = list(compress = 100)}.
\item AWS bucket and prefix for the \code{"aws_"} formats, e.g.
\code{resources = list(bucket = "your-bucket", prefix = "folder/name")}.
\code{bucket} is required for AWS formats. See the cloud computing chapter
of the manual for details.
}}

\item{storage}{Character of length 1, only relevant to
\code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[targets:tar_make_future]{tar_make_future()}}.
If \code{"main"}, the target's return value is sent back to the
host machine and saved locally. If \code{"worker"}, the worker
saves the value.}

\item{retrieval}{Character of length 1, only relevant to
\code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[targets:tar_make_future]{tar_make_future()}}.
If \code{"main"}, the target's dependencies are loaded on the host machine
and sent to the worker before the target builds.
If \code{"worker"}, the worker loads the targets dependencies.}

\item{cue}{An optional object from \code{tar_cue()} to customize the
rules that decide whether the target is up to date.}
}
\value{
\code{tar_stan_vb(name = x, ...)} returns a list
of \code{targets::tar_target()} objects:
\itemize{
\item \code{x_file}: reproducibly track the Stan model file.
\item \code{x_lines}: contents of the Stan model file.
Omitted if \code{compile = "original"}.
\item \code{x_data}: data for the variational Bayes computation.
\item \code{x_vb}: \code{CmdStanVB} object with all the VB results.
\item \code{x_draws}: tidy data frame of VB draws. Omitted if \code{draws = FALSE}.
\item \code{x_summary}: tidy data frame of VB summaries.
Omitted if \code{summary = FALSE}.
}
}
\description{
Targets to run a Stan model once with
variational Bayes and save multiple outputs.
}
\details{
Most of the arguments are passed to the \verb{$compile()},
\verb{$variational()}, and \verb{$summary()} methods of the \code{CmdStanModel} class.
If you previously compiled the model in an upstream \code{\link[=tar_stan_compile]{tar_stan_compile()}}
target, then the model should not recompile.
}
\examples{
# First, write your Stan model file. Example:
# tar_stan_example_file() # Writes stantargets_example.stan
# Then in _targets.R, write the pipeline:
targets::tar_pipeline(
  tar_stan_vb(
    your_model,
    file = "stantargets_example.stan",
    data = tar_stan_example_data(),
    variables = "beta",
    summaries = list(~quantile(.x, probs = c(0.25, 0.75)))
  )
)
}
