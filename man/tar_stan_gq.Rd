% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tar_stan_gq.R
\name{tar_stan_gq}
\alias{tar_stan_gq}
\title{Generated quantities on an existing CmdStanFit object}
\usage{
tar_stan_gq(
  name,
  stan_files,
  data = list(),
  fitted_params,
  compile = c("original", "copy"),
  quiet = TRUE,
  dir = NULL,
  include_paths = NULL,
  cpp_options = list(),
  stanc_options = list(),
  force_recompile = FALSE,
  seed = NULL,
  output_dir = NULL,
  sig_figs = NULL,
  parallel_chains = getOption("mc.cores", 1),
  threads_per_chain = NULL,
  variables = NULL,
  summaries = list(),
  summary_args = list(),
  draws = TRUE,
  summary = TRUE,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue")
)
}
\arguments{
\item{name}{Symbol, base name for the collection of targets.
The name itself will be applied to the fit object itself,
and there will be suffixes for various supporting targets.}

\item{stan_files}{Character vector of Stan model files to produce
the generated quantities. If you
supply multiple files, each model will run on the one shared dataset
generated by the code in \code{data}. If you supply an unnamed vector,
\code{tools::file_path_sans_ext(basename(stan_files))} will be used
as target name suffixes. If \code{stan_files} is a named vector,
the suffixed will come from \code{names(stan_files)}.}

\item{data}{Code to generate the \code{data}
argument of \verb{$generate_quantities()}.}

\item{fitted_params}{Symbol, name of a \code{CmdStanFit} object
computed in a previous target: for example, the
\verb{*_mcmc_*} target from \code{\link[=tar_stan_mcmc]{tar_stan_mcmc()}}. Must be a subclass
that \verb{$generate_quantities()} can accept as \code{fitted_params}.}

\item{compile}{Do compilation? The default is \code{TRUE}. If \code{FALSE}
compilation can be done later via the \code{\link[cmdstanr:model-method-compile]{$compile()}}
method.}

\item{quiet}{\code{quiet} argument to \verb{$compile()}.}

\item{dir}{\code{dir} argument to \verb{$compile()}.}

\item{include_paths}{\code{include_paths} argument to \verb{$compile()}.}

\item{cpp_options}{\code{cpp_options} argument to \verb{$compile()}.}

\item{stanc_options}{\code{stanc_options} argument to \verb{$compile()}.}

\item{force_recompile}{\code{force_recompile} argument to \verb{$compile()}.}

\item{seed}{\code{seed} argument to \verb{$generate_quantities()}.}

\item{output_dir}{\code{output_dir} argument to \verb{$generate_quantities()}.}

\item{sig_figs}{\code{sig_figs} argument to \verb{$generate_quantities()}.}

\item{parallel_chains}{\code{parallel_chains} argument to
\verb{$generate_quantities()}.}

\item{threads_per_chain}{\code{threads_per_chain} argument to
\verb{$generate_quantities()}.}

\item{variables}{\code{variables} argument to \verb{$draws()} and \verb{$summary()}
on the \code{CmdStanGQ} object.}

\item{summaries}{Optional list of summary functions passed to \code{...} in
\code{posterior::summarize_draws()} through \verb{$summary()}
on the \code{CmdStanFit} object.}

\item{summary_args}{Optional list of summary function arguments passed to
\code{.args} in \code{posterior::summarize_draws()} through \verb{$summary()}
on the \code{CmdStanFit} object.}

\item{draws}{Logical, whether to create a target for posterior draws.
Saves \code{posterior::as_draws_df(fit$draws())} to a compressed \code{tibble}.
Convenient, but duplicates storage.}

\item{summary}{Logical, whether to create a target for
\code{fit$summary()}.}

\item{tidy_eval}{Logical, whether to enable tidy evaluation
when interpreting \code{command} and \code{pattern}. If \code{TRUE}, you can use the
"bang-bang" operator \verb{!!} to programmatically insert
the values of global objects.}

\item{packages}{Character vector of packages to load right before
the target builds. Use \code{tar_option_set()} to set packages
globally for all subsequent targets you define.}

\item{library}{Character vector of library paths to try
when loading \code{packages}.}

\item{error}{Character of length 1, what to do if the target
runs into an error. If \code{"stop"}, the whole pipeline stops
and throws an error. If \code{"continue"}, the error is recorded,
but the pipeline keeps going.}

\item{memory}{Character of length 1, memory strategy.
If \code{"persistent"}, the target stays in memory
until the end of the pipeline (unless \code{storage} is \code{"worker"},
in which case \code{targets} unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If \code{"transient"}, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files such as \code{format = "aws_file"},
this memory policy applies to
temporary local copies of the file in \verb{_targets/scratch/"}:
\code{"persistent"} means they remain until the end of the pipeline,
and \code{"transient"} means they get deleted from the file system
as soon as possible. The former conserves bandwidth,
and the latter conserves local storage.}

\item{garbage_collection}{Logical, whether to run \code{base::gc()}
just before the target runs.}

\item{deployment}{Character of length 1, only relevant to
\code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[targets:tar_make_future]{tar_make_future()}}. If \code{"worker"},
the target builds on a parallel worker. If \code{"main"},
the target builds on the host machine / process managing the pipeline.}

\item{priority}{Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get built earlier.
Only applies to \code{\link[targets:tar_make_future]{tar_make_future()}} and \code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}}
(not \code{\link[targets:tar_make]{tar_make()}}). \code{\link[targets:tar_make_future]{tar_make_future()}} with no extra settings is
a drop-in replacement for \code{\link[targets:tar_make]{tar_make()}} in this case.}

\item{resources}{A named list of computing resources. Uses:
\itemize{
\item Template file wildcards for \code{future::future()} in \code{\link[targets:tar_make_future]{tar_make_future()}}.
\item Template file wildcards \code{clustermq::workers()} in \code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}}.
\item Custom target-level \code{future::plan()}, e.g.
\code{resources = list(plan = future.callr::callr)}.
\item Custom \code{curl} handle if \code{format = "url"},
e.g. \code{resources = list(handle = curl::new_handle())}.
\item Custom preset for \code{qs::qsave()} if \code{format = "qs"}, e.g.
\code{resources = list(handle = "archive")}.
\item Custom compression level for \code{fst::write_fst()} if
\code{format} is \code{"fst"}, \code{"fst_dt"}, or \code{"fst_tbl"}, e.g.
\code{resources = list(compress = 100)}.
\item AWS bucket and prefix for the \code{"aws_"} formats, e.g.
\code{resources = list(bucket = "your-bucket", prefix = "folder/name")}.
\code{bucket} is required for AWS formats. See the cloud computing chapter
of the manual for details.
}}

\item{storage}{Character of length 1, only relevant to
\code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[targets:tar_make_future]{tar_make_future()}}.
If \code{"main"}, the target's return value is sent back to the
host machine and saved locally. If \code{"worker"}, the worker
saves the value.}

\item{retrieval}{Character of length 1, only relevant to
\code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[targets:tar_make_future]{tar_make_future()}}.
If \code{"main"}, the target's dependencies are loaded on the host machine
and sent to the worker before the target builds.
If \code{"worker"}, the worker loads the targets dependencies.}

\item{cue}{An optional object from \code{tar_cue()} to customize the
rules that decide whether the target is up to date.}
}
\value{
\code{tar_stan_gq(name = x, ...)} returns a list
of \code{targets::tar_target()} objects:
\itemize{
\item \code{x_file}: reproducibly track the Stan model file.
\item \code{x_lines}: contents of the Stan model file.
Omitted if \code{compile = "original"}.
\item \code{x_data}: data for the generated quantities.
\item \code{x_gq}: \code{CmdStanGQ} object with all the generated quantities results.
\item \code{x_draws}: tidy data frame of draws. Omitted if \code{draws = FALSE}.
\item \code{x_summary}: tidy data frame of summaries.
Omitted if \code{summary = FALSE}.
}
}
\description{
Targets to run the generated quantities of
a Stan model and optionally save draws and summaries separately.
}
\details{
Most of the arguments are passed to the \verb{$compile()},
\verb{$generate_quantities()}, and \verb{$summary()} methods
of the \code{CmdStanModel} class. If you
previously compiled the model in an upstream \code{\link[=tar_stan_compile]{tar_stan_compile()}}
target, then the model should not recompile.
}
\examples{
# First, write your Stan model file. Example:
# tar_stan_example_file() # Writes stantargets_example.stan
# Then in _targets.R, write the pipeline:
targets::tar_pipeline(
  tar_stan_mcmc(
    your_model,
    stan_files = "stantargets_example.stan",
    data = tar_stan_example_data()
  ),
  tar_stan_gq(
    custom_gq,
    stan_files = "stantargets_example.stan", # Can be a different model.
    fitted_params = your_model_mcmc,
    data = your_model_data # Can be a different dataset.
  )
)
}
